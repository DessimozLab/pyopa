\documentclass[12pt]{article}

\title{Summer Internship: Migrating Integral Darwin Functionalities to Python}

\author{Ferenc Galk\'o  \\
    ferenc.galko@gmail.com}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section{Introduction}
This document contains a concise summation of the functionalities offered by this new python package. The main goal of the project is to facilitate various operations on sequences, with the performance of an optimized C code and the convenience of Python.

The currently available features include the Smith-Waterman algorithm, producing both the scores and the concrete strings as well as byte and short estimations. 

While the existing code base was developed on Linux, it is also compatible with Windows and iOS. To install the package, you should simply extract the project into a separate folder, navigate there, and use the \emph{python setup.py install}, assuming that \emph{numpy} and \emph{Cython} are already installed. 

This will automatically compile the  C core according to your operating system (which means a Visual Studio compiler must be available on Windows). 
\section{Byte and short estimations}
Instead of calculating the actual double score for two given sequences, we can rapidly produce an upper bound of the score. If this upper bound score is lower than the threshold of interest, we can omit the calculation of the double precision score for these particular sequences.

If the upper bound score is over the threshold, however, we have do another alignment to get the actual
 score, which can still be lower than the threshold. Since the vast majority of the scores is usually lower than the threshold, a substantial amount of time can be saved by using the byte or short estimation, because an estimation runs much faster than a double alignment.

To produce an upper bound by the short (or the byte) method, we have to transform the double distance matrix and the gap costs to shorts (or bytes). The transformation has to be done in a way that the future calculations will surely produce an upper bound score. Such a transformation could be $ceil(x)$ for every element, but this would result in a really imprecise upper bound score. Instead, we use $ceil(x \cdot factor)$ with $factor=UNSIGNED\_SHORT\_MAX / threshold$ for the short version, and a bit more complicated formula for the byte version. The factor should be designed in a way that it reduces the relative rounding errors, for a more precise estimation.

After the transformations, we can cram multiple elements into a single register (8 for the short version and 16 for the byte version, assuming 128-bit SSE registers) and perform the calculation. Of course the result score has to be scaled back by the used $factor$.

To hasten the estimation further, we can create so-called profiles for a given $S$ sequence and matrix combination. After a profile is created, we can use it for multiple alignments to the same $S$ and matrix combination.

\section{Structure of the project}
The project consists of two sub-projects, a C core and a Python wrapper. The C core can be found in the \emph{c\_source} folder, which is contained by the Python project.

The list of C core files and their short purpose:
\begin{itemize}
	\item \emph{Python\_extension.c}:\\
	Contains the implementation of the vectorized double version of the alignment algorithm, the concrete alignment and provides an interface for Python.
	\item \emph{DynProgr\_sse\_short.c}:\\
	Contains the implementation of the short score estimation.
	\item \emph{DynProgr\_sse\_byte.c}:\\
	Contains the implementation of the byte score estimation.
	\item \emph{DynProgr\_scalar.c}:\\
		Contains the reference double precision implementation.
	\item \emph{EstimatePam.c}:\\
		Contains the implementation of the EstimatePam function.
	\item \emph{Page\_size.c}:\\
	Used to determine the page size in a platform independent mode.
\end{itemize}

The structure of the Python project:
\begin{itemize}
	\item \emph{test}: Stores the data and the test scripts.
	\begin{itemize}
		\item \emph{test\_darwin.py}: Unit test for checking the conformity of the Python package with Darwin.
		\item \emph{test\_input.py}: Unit test for checking whether the appropriate Exceptions are raised on erroneous inputs.
		\item \emph{data}: This folder stores the results generated from Darwin, the matrices and other data necessary by the tests.
	\end{itemize}
	\item \emph{examples}: This folder stores the examples provided with the package.
	\item \emph{cython\_swps3.pxd}: Defines the C functions available from Python.
	\item \emph{cython\_swps3.pyx}: Contains the vast majority of the Python code. All of the Python classes and functions, which are discussed in this document, are implemented in this file.
	\item \emph{setup.py}: Contains the necessary code to install the package. The \emph{-DPY\_DEBUG} could be used for debugging purposes.
	\item \emph{MANIFEST.in}: Defines the files that should be included in the source distribution.
\end{itemize}

\section{Migrated Functionalities}
This section summarizes the functionalities offered by the package. An example file with in-detail comments, which demonstrate all of the features, can be found at $example/example.py$. A detailed description of the available functions and classes can be found in the $.pyx$ file.

\subsection{General Functions and Classes}
List of general purpose functions:
\begin{itemize}

  \item \emph{normalize\_sequence(s, allow\_underscore=False)}:\\ 
   Subtracts the ASCII value of 'A' from every character in the given string. This is necessary because the C core
    is working on these kind of inputs.
  \item \emph{create\_environment(gap\_open, gap\_ext, pam\_distance, scores, column\_order)}:\\
  Creates an environment from the given parameters.
  \item \emph{read\_env\_json(json\_data)}:\\
  This function reads an AlignmentEnvironment from a JSON object or a file that contains the JSON data
  \item \emph{generate\_env(log\_pam1\_env, new\_pam, threshold=85.0)}:\\
    Generates a new AlignmentEnvironment from the given log\_pam1 environment by using the new\_pam pam distance and
    the given threshold.
  \item \emph{generate\_all\_env(log\_pam1\_env, env\_num, starting\_pam=0.04944973,  threshold=85.0)}:\\
        Generates a list of environments starting from the given pam distance.
\end{itemize}
List of general purpose classes:
\begin{itemize}
	\item \emph{AlignmentEnvironment}:\\
	    This class stores all the information that is necessary to conduct an alignment (including the matrix and the gap
    costs). It does the necessary transformations such as scaling up the matrix and gap costs and extending the matrix
    to a 26x26 one, which is needed for scalar and byte alignments. Although you can manually create the necessary
    matrices and gap costs it is highly recommended to use this class for alignments.
\end{itemize}

\subsection{Byte and short functions and classes}
List of functions associated with the byte and short estimations:
\begin{itemize}
	\item {align\_short(s1, s2, env, is\_normalized=False)}:\\
    Aligns two sequences by using the matrix and gap costs defined in the file/AlignmentEnvironment.
    This is not an efficient way to align
    sequences and should only be used for testing purposes.
	\item \emph{align\_byte(s1, s2, env, is\_normalized=False)}:\\
    Aligns two sequences by using the matrix and gap costs defined in the file/AlignmentEnvironment.
    This is not an efficient way to align
    sequences and should only be used for testing purposes.
	
\end{itemize}
List of classes associated with the byte and short estimations:
\begin{itemize}
	\item \emph{AlignmentProfile}:\\
	This class is used to facilitate multiple alignment by using the same query and matrix with the C core SSE byte and
    short alignments. From the given query and matrix we can generate a so-called "profile" in C, which makes it
    possible to efficiently align multiple consecutive S strings to the same query. We can either create a short or a
    byte profile respectively for the short and byte C core alignment.
\end{itemize}
\subsection{Actual score and concrete alignment}

List of functions associated with concrete alignment:
\begin{itemize}
	\item \emph{align\_strings(s1, s2, env, is\_normalized=False, is\_global=False, provided\_alig=None)}:\\
	Does the concrete string alignment for two given strings. Returns the two aligned strings.
	\item \emph{align\_double(s1, s2, env, is\_normalized=False, stop\_at\_threshold=False, is\_global=False, calculate\_ranges=True)}:\\
	 A vectorized implementation of the double precision alignment algorithm.
	 \item \emph{align\_scalar\_reference\_local(s1, s2, env, is\_normalized=False)}:\\
	 This is a simpler interface to the scalar alignment function written in C by using the AlignmentEnvironment python
    class. This is a reference implementation and not vectorized.
    \item \emph{MutipleAlEnv}:\\
        This class stores a list of DayHoff matrices generated from C. It can be generated from a list of
     AlignmentEnvironments and can be used to call the EstimatePam function, which is implemented in C.
\end{itemize}

\end{document}